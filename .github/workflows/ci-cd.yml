name: CI/CD Pipeline

on:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write  # For semantic-release to create tags and releases
  packages: write  # For publishing Docker images to GHCR
  pull-requests: write # For creating PRs and commenting on them
  issues: write  # For creating issues and commenting on them

jobs:
  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Required for commitlint to analyze all commit messages
          
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm install
        
      - name: Lint commit messages
        run: npx commitlint --from $(git rev-list --max-parents=0 HEAD) --to HEAD || echo "Commit linting warnings found but continuing build"

  test:
    name: Test
    runs-on: ubuntu-latest
    needs: [lint]
    steps:
      - uses: actions/checkout@v4
      
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm install
        
      - name: Run tests
        run: npm test
        env:
          # Use mock mode for tests to avoid hitting real API endpoints
          NODE_ENV: test
          MOCK_API: true

  build:
    name: Build
    runs-on: ubuntu-latest
    needs: [test]
    steps:
      - uses: actions/checkout@v4
      
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm install
        
      - name: Build
        run: npm run build
        
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: build/
          retention-days: 1

  release:
    name: Semantic Release
    runs-on: ubuntu-latest
    needs: [build, test]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    outputs:
      new_release_published: ${{ steps.semantic-release.outputs.new_release_published }}
      new_release_version: ${{ steps.semantic-release.outputs.new_release_version }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Required for semantic-release to analyze all commit messages
          persist-credentials: true
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          registry-url: 'https://registry.npmjs.org'
      
      - name: Install dependencies
        run: npm install
      
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
          path: .
      
      # Verify release configuration before running semantic-release
      - name: Verify Release Configuration
        run: |
          echo "Verifying release configuration..."
          npm run verify-release-config
          if [ $? -ne 0 ]; then
            echo "::error::Release configuration verification failed!"
            exit 1
          fi
          echo "Release configuration verification passed!"

      # Ensure we have all tags and history for semantic-release to work properly
      - name: Fetch complete Git history
        run: |
          echo "Fetching complete Git history and tags..."
          git fetch --tags --force --depth=1000
          git fetch origin main --depth=1000
          git fetch origin dev --depth=1000
          
          echo "Git tags:"
          git tag -l
          
          echo "Latest commits:"
          git log --oneline -15
          
      # Generate semantic version, changelog from commit messages, create GitHub release
      - name: Semantic Release
        id: semantic-release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DEBUG: "semantic-release:*"
        run: |
          npx semantic-release --debug
          
          # Extract version from package.json for subsequent jobs if semantic-release succeeds but doesn't set outputs
          if [ $? -eq 0 ]; then
            VERSION=$(node -p "require('./package.json').version")
            echo "new_release_published=true" >> $GITHUB_OUTPUT
            echo "new_release_version=$VERSION" >> $GITHUB_OUTPUT
            echo "Successfully released version: $VERSION"
          else
            echo "::error::Semantic release failed or determined no release is needed"
            echo "new_release_published=false" >> $GITHUB_OUTPUT
          fi
        
      - name: Log version info
        if: steps.semantic-release.outputs.new_release_published == 'true'
        run: |
          echo "New release published: ${{ steps.semantic-release.outputs.new_release_published }}"
          echo "New release version: ${{ steps.semantic-release.outputs.new_release_version }}"
  
  publish-docker:
    name: Publish Docker Image to GHCR
    runs-on: ubuntu-latest
    needs: [release]
    if: needs.release.outputs.new_release_published == 'true'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main  # Ensure we're using the code from main branch after release

      # Check if this version already exists in the registry
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Check if image already exists
        id: check_image
        run: |
          VERSION="${{ needs.release.outputs.new_release_version }}"
          echo "Checking if Docker image for version $VERSION already exists..."
          
          # Try to pull the image manifest - will fail if it doesn't exist
          if docker buildx imagetools inspect ghcr.io/${{ github.repository }}:$VERSION &>/dev/null; then
            echo "Image already exists in registry. Skipping build."
            echo "image_exists=true" >> $GITHUB_OUTPUT
          else
            echo "Image does not exist yet. Proceeding with build."
            echo "image_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Set up QEMU
        if: steps.check_image.outputs.image_exists != 'true'
        uses: docker/setup-qemu-action@v3
      
      - name: Set up Docker Buildx
        if: steps.check_image.outputs.image_exists != 'true'
        uses: docker/setup-buildx-action@v3
      
      # Build AMD64 image
      - name: Build and push AMD64 image
        if: steps.check_image.outputs.image_exists != 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          push: true
          tags: |
            ghcr.io/${{ github.repository }}:${{ needs.release.outputs.new_release_version }}-amd64
            ghcr.io/${{ github.repository }}:latest-amd64
          build-args: |
            NODE_VERSION=20
          cache-from: type=registry,ref=ghcr.io/${{ github.repository }}:latest-amd64
          cache-to: type=inline
      
      # Build ARM64 image with memory settings for ARM builds
      - name: Build and push ARM64 image
        if: steps.check_image.outputs.image_exists != 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/arm64
          push: true
          tags: |
            ghcr.io/${{ github.repository }}:${{ needs.release.outputs.new_release_version }}-arm64
            ghcr.io/${{ github.repository }}:latest-arm64
          build-args: |
            NODE_VERSION=20
            NODE_OPTIONS=--max_old_space_size=4096
          cache-from: type=registry,ref=ghcr.io/${{ github.repository }}:latest-arm64
          cache-to: type=inline
      
      # Create multi-architecture manifest
      - name: Create and push manifest
        if: steps.check_image.outputs.image_exists != 'true'
        run: |
          docker buildx imagetools create -t ghcr.io/${{ github.repository }}:${{ needs.release.outputs.new_release_version }} \
            ghcr.io/${{ github.repository }}:${{ needs.release.outputs.new_release_version }}-amd64 \
            ghcr.io/${{ github.repository }}:${{ needs.release.outputs.new_release_version }}-arm64
          
          docker buildx imagetools create -t ghcr.io/${{ github.repository }}:latest \
            ghcr.io/${{ github.repository }}:latest-amd64 \
            ghcr.io/${{ github.repository }}:latest-arm64
      
      # Summary
      - name: Docker Publish Summary
        run: |
          VERSION="${{ needs.release.outputs.new_release_version }}"
          if [[ "${{ steps.check_image.outputs.image_exists }}" == "true" ]]; then
            echo "Image for version $VERSION already exists in the registry. No new image was built."
          else
            echo "Successfully built and published Docker image for version $VERSION."
          fi

  publish-npm:
    name: Publish Package to NPM
    runs-on: ubuntu-latest
    needs: [release]
    if: needs.release.outputs.new_release_published == 'true'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main  # Ensure we're using the code from main branch after release
          fetch-depth: 0  # Fetch all history for proper versioning
          fetch-tags: true # Fetch all tags to ensure release tag is available
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          registry-url: 'https://registry.npmjs.org'
      
      - name: Verify NPM_TOKEN secret
        env:
          CHECK_TOKEN: ${{ secrets.NPM_TOKEN != '' }}
        run: |
          if [[ "$CHECK_TOKEN" != "true" ]]; then
            echo "::error::NPM_TOKEN secret is not set. Cannot publish to NPM."
            exit 1
          else
            echo "NPM_TOKEN secret is available"
          fi
      
      # Check if this version already exists in the npm registry
      - name: Check if package version already exists
        id: check_package
        run: |
          VERSION="${{ needs.release.outputs.new_release_version }}"
          echo "Checking if npm package for version $VERSION already exists..."
          
          # Try to get version info from npm - will exit with non-zero if it doesn't exist
          if npm view mcp-grocy-api@$VERSION version &>/dev/null; then
            echo "Package already exists in registry. Skipping publish."
            echo "package_exists=true" >> $GITHUB_OUTPUT
          else
            echo "Package does not exist yet. Proceeding with publish."
            echo "package_exists=false" >> $GITHUB_OUTPUT
          fi

      # Install dependencies
      - name: Install dependencies
        if: steps.check_package.outputs.package_exists != 'true'
        run: npm install
      
      # Build the package
      - name: Build
        if: steps.check_package.outputs.package_exists != 'true'
        run: npm run build
      
      # Update package.json version to match release if needed
      - name: Ensure package version matches release version
        if: steps.check_package.outputs.package_exists != 'true'
        run: |
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          RELEASE_VERSION="${{ needs.release.outputs.new_release_version }}"
          
          if [ "$CURRENT_VERSION" != "$RELEASE_VERSION" ]; then
            echo "Updating package.json version from $CURRENT_VERSION to $RELEASE_VERSION"
            npm version $RELEASE_VERSION --no-git-tag-version
          else
            echo "Package.json version already matches release version: $CURRENT_VERSION"
          fi
      
      # Publish to npm with better error handling and retries
      - name: Publish package
        if: steps.check_package.outputs.package_exists != 'true'
        run: |
          # Publish with retry logic
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if npm publish --access public; then
              echo "Package published successfully to NPM"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT+1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Publish failed, retrying in 10 seconds (attempt $RETRY_COUNT/$MAX_RETRIES)..."
                sleep 10
              else
                echo "::error::Failed to publish package after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
      
      # Summary
      - name: NPM Publish Summary
        run: |
          VERSION="${{ needs.release.outputs.new_release_version }}"
          if [[ "${{ steps.check_package.outputs.package_exists }}" == "true" ]]; then
            echo "Package for version $VERSION already exists in the registry. No new package was published."
          else
            echo "Successfully published NPM package version $VERSION."
          fi

  publish-hassio-addons:
    name: Publish to Hass.io Addons
    runs-on: ubuntu-latest
    needs: [release]
    # Always update the submodule for main branch pushes - no version condition
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      # Get the current project for updating config.yaml
      - name: Checkout current repository
        uses: actions/checkout@v4
        with:
          path: current-repo
          
      # Update version in config.yaml to match the release
      - name: Update version in config.yaml
        if: needs.release.outputs.new_release_published == 'true'
        working-directory: current-repo
        run: |
          VERSION="${{ needs.release.outputs.new_release_version }}"
          echo "Updating config.yaml to version $VERSION"
          sed -i "s/version: \"[0-9]*\.[0-9]*\.[0-9]*\"/version: \"$VERSION\"/" config.yaml
          cat config.yaml | grep version
          
          # Commit the change to the repository
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add config.yaml
          git commit -m "chore(release): update config.yaml to version $VERSION [skip ci]"
          git push
      
      - name: Checkout hassio-addons repository
        uses: actions/checkout@v4
        with:
          repository: saya6k/hassio-addons
          token: ${{ secrets.HASSIO_ADDONS_TOKEN }}
          path: hassio-addons

      - name: Setup Git configuration
        working-directory: hassio-addons
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
      
      - name: Check if submodule exists
        id: check-submodule
        working-directory: hassio-addons
        run: |
          if grep -q "mcp-grocy-api" .gitmodules 2>/dev/null; then
            echo "SUBMODULE_EXISTS=true" >> $GITHUB_OUTPUT
          else
            echo "SUBMODULE_EXISTS=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Update existing submodule
        if: steps.check-submodule.outputs.SUBMODULE_EXISTS == 'true'
        working-directory: hassio-addons
        run: |
          # More robust submodule update that doesn't fail if there are issues with other submodules
          git config -f .gitmodules --get-regexp '^submodule\.mcp-grocy-api\.path$' || true
          
          # Check if the directory exists and is a git repository
          if [ -d "mcp-grocy-api" ] && [ -d "mcp-grocy-api/.git" ]; then
            cd mcp-grocy-api
            git fetch
            git checkout main
            git pull
            cd ..
          else
            # If directory doesn't exist or isn't a git repo, initialize just this submodule
            git submodule init mcp-grocy-api
            git submodule update --remote mcp-grocy-api
          fi
          
          # Commit the updated submodule
          git add mcp-grocy-api
          git commit -m "chore: update mcp-grocy-api submodule to latest version" || echo "No changes to commit"
          git push || echo "No changes to push"
      
      - name: Check and update gitignore
        if: steps.check-submodule.outputs.SUBMODULE_EXISTS == 'false'
        working-directory: hassio-addons
        run: |
          # Check if mcp-grocy-api is in .gitignore
          if grep -q "mcp-grocy-api" .gitignore 2>/dev/null; then
            # Remove or comment out the line from .gitignore
            sed -i 's/mcp-grocy-api/#mcp-grocy-api - submodule now/g' .gitignore
            git add .gitignore
            git commit -m "chore: update .gitignore to allow mcp-grocy-api submodule"
            git push
          fi
      
      - name: Add new submodule if it doesn't exist
        # This step will only run if the submodule doesn't exist
        # and the previous step didn't find it in .gitignore
        if: steps.check-submodule.outputs.SUBMODULE_EXISTS == 'false'
        working-directory: hassio-addons
        run: |
          # Add the new submodule with force flag
          git submodule add -f https://github.com/saya6k/mcp-grocy-api.git mcp-grocy-api
          
          # Directly initialize just this submodule without trying to init others
          cd mcp-grocy-api
          git checkout main
          cd ..
          
          # Commit the new submodule
          git add .gitmodules mcp-grocy-api
          git commit -m "chore: add mcp-grocy-api submodule"
          git push

  sync-dev:
    name: Sync Dev Branch with Main
    runs-on: ubuntu-latest
    needs: [release, publish-docker, publish-npm, publish-hassio-addons]
    if: needs.release.outputs.new_release_published == 'true'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history
          ref: main  # Start with main branch

      - name: Setup Git
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          
      - name: Sync dev branch with main
        run: |
          # Fetch all branches
          git fetch origin
          
          # Check if dev branch exists
          if git ls-remote --heads origin dev | grep -q 'dev'; then
            # Create tracking branch for dev
            git checkout --track origin/dev || git checkout dev
            
            # Merge main into dev
            git merge origin/main -m "chore(sync): merge main into dev after release ${{ needs.release.outputs.new_release_version }} [skip ci]"
            
            # Push changes to dev
            git push origin dev
            
            echo "Successfully synchronized dev branch with main"
          else
            echo "Dev branch does not exist. Skipping synchronization."
          fi
