name: CI/CD Pipeline

on:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write  # For semantic-release to create tags and releases
  packages: write  # For publishing Docker images to GHCR
  pull-requests: write # For creating PRs and commenting on them
  issues: write  # For creating issues and commenting on them

jobs:
  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Required for commitlint to analyze all commit messages
          
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm install
        
      - name: Lint commit messages
        run: npx commitlint --from $(git rev-list --max-parents=0 HEAD) --to HEAD || echo "Commit linting warnings found but continuing build"

  test:
    name: Test
    runs-on: ubuntu-latest
    needs: [lint]
    steps:
      - uses: actions/checkout@v4
      
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm install
        
      - name: Run tests
        run: npm test
        env:
          # Use mock mode for tests to avoid hitting real API endpoints
          NODE_ENV: test
          MOCK_API: true

  build:
    name: Build
    runs-on: ubuntu-latest
    needs: [test]
    steps:
      - uses: actions/checkout@v4
      
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm install
        
      - name: Build
        run: npm run build
        
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: build/
          retention-days: 1

  release:
    name: Semantic Release
    runs-on: ubuntu-latest
    needs: [build, test]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    outputs:
      new_release_published: ${{ steps.semantic-release.outputs.new_release_published }}
      new_release_version: ${{ steps.semantic-release.outputs.new_release_version }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Required for semantic-release to analyze all commit messages
          persist-credentials: true
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          registry-url: 'https://registry.npmjs.org'
      
      - name: Install dependencies
        run: npm install
      
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
          path: .
      
      # Verify release configuration before running semantic-release
      - name: Verify Release Configuration
        run: |
          echo "Verifying release configuration..."
          npm run verify-release-config
          if [ $? -ne 0 ]; then
            echo "::error::Release configuration verification failed!"
            exit 1
          fi
          echo "Release configuration verification passed!"

      # Ensure we have all tags and history for semantic-release to work properly
      - name: Fetch complete Git history
        run: |
          echo "Fetching complete Git history and tags..."
          git fetch --tags --force --depth=1000
          git fetch origin main --depth=1000
          git fetch origin dev --depth=1000
          
          echo "Git tags:"
          git tag -l
          
          echo "Latest commits:"
          git log --oneline -15
          
      # Generate semantic version, changelog from commit messages, create GitHub release
      - name: Semantic Release
        id: semantic-release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DEBUG: "semantic-release:*"
        run: |
          npx semantic-release --debug
          
          # Extract version from package.json for subsequent jobs if semantic-release succeeds but doesn't set outputs
          if [ $? -eq 0 ]; then
            VERSION=$(node -p "require('./package.json').version")
            echo "new_release_published=true" >> $GITHUB_OUTPUT
            echo "new_release_version=$VERSION" >> $GITHUB_OUTPUT
            echo "Successfully released version: $VERSION"
          else
            echo "::error::Semantic release failed or determined no release is needed"
            echo "new_release_published=false" >> $GITHUB_OUTPUT
          fi
        
      # Ensure release version is set for downstream jobs
      - name: Ensure release version output is set
        if: steps.semantic-release.outputs.new_release_version == '' || steps.semantic-release.outputs.new_release_version == null
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "new_release_version=$VERSION" >> $GITHUB_OUTPUT
          echo "new_release_published=true" >> $GITHUB_OUTPUT
          echo "Set new_release_version to $VERSION from package.json"
        
      - name: Log version info
        if: steps.semantic-release.outputs.new_release_published == 'true'
        run: |
          echo "New release published: ${{ steps.semantic-release.outputs.new_release_published }}"
          echo "New release version: ${{ steps.semantic-release.outputs.new_release_version }}"
  
  publish-npm:
    name: Publish Package to NPM
    runs-on: ubuntu-latest
    needs: [release]
    if: needs.release.outputs.new_release_published == 'true'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main  # Ensure we're using the code from main branch after release
          fetch-depth: 0  # Fetch all history for proper versioning
          fetch-tags: true # Fetch all tags to ensure release tag is available
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          registry-url: 'https://registry.npmjs.org'
      
      - name: Verify NPM_TOKEN secret
        env:
          CHECK_TOKEN: ${{ secrets.NPM_TOKEN != '' }}
        run: |
          if [[ "$CHECK_TOKEN" != "true" ]]; then
            echo "::error::NPM_TOKEN secret is not set. Cannot publish to NPM."
            exit 1
          else
            echo "NPM_TOKEN secret is available"
          fi
      
      # Check if this version already exists in the npm registry
      - name: Check if package version already exists
        id: check_package
        run: |
          VERSION="${{ needs.release.outputs.new_release_version }}"
          echo "Checking if npm package for version $VERSION already exists..."
          
          # Try to get version info from npm - will exit with non-zero if it doesn't exist
          if npm view mcp-grocy-api@$VERSION version &>/dev/null; then
            echo "Package already exists in registry. Skipping publish."
            echo "package_exists=true" >> $GITHUB_OUTPUT
          else
            echo "Package does not exist yet. Proceeding with publish."
            echo "package_exists=false" >> $GITHUB_OUTPUT
          fi

      # Install dependencies
      - name: Install dependencies
        if: steps.check_package.outputs.package_exists != 'true'
        run: npm install
      
      # Build the package
      - name: Build
        if: steps.check_package.outputs.package_exists != 'true'
        run: npm run build
      
      # Update package.json version to match release if needed
      - name: Ensure package version matches release version
        if: steps.check_package.outputs.package_exists != 'true'
        run: |
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          RELEASE_VERSION="${{ needs.release.outputs.new_release_version }}"
          
          if [ "$CURRENT_VERSION" != "$RELEASE_VERSION" ]; then
            echo "Updating package.json version from $CURRENT_VERSION to $RELEASE_VERSION"
            npm version $RELEASE_VERSION --no-git-tag-version
          else
            echo "Package.json version already matches release version: $CURRENT_VERSION"
          fi
      
      # Publish to npm with better error handling and retries
      - name: Publish package
        if: steps.check_package.outputs.package_exists != 'true'
        run: |
          # Publish with retry logic
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if npm publish --access public; then
              echo "Package published successfully to NPM"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT+1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Publish failed, retrying in 10 seconds (attempt $RETRY_COUNT/$MAX_RETRIES)..."
                sleep 10
              else
                echo "::error::Failed to publish package after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
      
      # Summary
      - name: NPM Publish Summary
        run: |
          VERSION="${{ needs.release.outputs.new_release_version }}"
          if [[ "${{ steps.check_package.outputs.package_exists }}" == "true" ]]; then
            echo "Package for version $VERSION already exists in the registry. No new package was published."
          else
            echo "Successfully published NPM package version $VERSION."
          fi


  publish-docker:
    name: Publish Docker Image to GHCR
    runs-on: ubuntu-latest
    needs: [publish-npm, release]
    if: needs.release.outputs.new_release_published == 'true'
    env:
      RELEASE_VERSION: ${{ needs.release.outputs.new_release_version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main  # Ensure we're using the code from main branch after release

      # Fail early if release version is not set
      - name: Check release version is set
        run: |
          if [ -z "$RELEASE_VERSION" ]; then
            echo "Fallback: version from package.json: $RELEASE_VERSION"
          fi
          if [ -z "$RELEASE_VERSION" ]; then
            exit 1
          fi
          echo "Using version: $RELEASE_VERSION"
        shell: bash

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Check if image already exists
        id: check_image
        run: |
          if [ -z "$RELEASE_VERSION" ]; then
            export RELEASE_VERSION=$(node -p "require('./package.json').version")
          fi
          echo "Checking if Docker image for version $RELEASE_VERSION already exists..."
          if docker buildx imagetools inspect ghcr.io/${{ github.repository }}:$RELEASE_VERSION &>/dev/null; then
            echo "image_exists=true" >> $GITHUB_OUTPUT
          else
            echo "image_exists=false" >> $GITHUB_OUTPUT
          fi
        shell: bash

      - name: Set up QEMU
        if: steps.check_image.outputs.image_exists != 'true'
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        if: steps.check_image.outputs.image_exists != 'true'
        uses: docker/setup-buildx-action@v3

      - name: Build and push AMD64 image
        if: steps.check_image.outputs.image_exists != 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          push: true
          tags: |
            ghcr.io/${{ github.repository }}:latest-amd64
          build-args: |
            NODE_VERSION=20
          cache-from: type=registry,ref=ghcr.io/${{ github.repository }}:latest-amd64
          cache-to: type=inline

      - name: Build and push ARM64 image
        if: steps.check_image.outputs.image_exists != 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/arm64
          push: true
          tags: |
            ghcr.io/${{ github.repository }}:latest-arm64
          build-args: |
            NODE_OPTIONS=--max_old_space_size=4096
          cache-from: type=registry,ref=ghcr.io/${{ github.repository }}:latest-arm64
          cache-to: type=inline

      - name: Create and push manifest
        if: steps.check_image.outputs.image_exists != 'true'
        run: |
          if [ -z "$RELEASE_VERSION" ]; then
            # This fallback should ideally not be needed if 'release' job works.
            export RELEASE_VERSION=$(node -p "require('./package.json').version")
            if [ -z "$RELEASE_VERSION" ]; then
              echo "Error: RELEASE_VERSION is empty and could not be determined from package.json."
              exit 1
            fi
          fi
          echo "Creating manifest for version: $RELEASE_VERSION"
          # Create manifest for the specific version tag - command on a single line
          docker buildx imagetools create -t ghcr.io/${{ github.repository }}:$RELEASE_VERSION ghcr.io/${{ github.repository }}:latest-amd64 ghcr.io/${{ github.repository }}:latest-arm64
          echo "Creating manifest for tag: latest"
          # Create manifest for the 'latest' tag - command on a single line
          docker buildx imagetools create -t ghcr.io/${{ github.repository }}:latest ghcr.io/${{ github.repository }}:latest-amd64 ghcr.io/${{ github.repository }}:latest-arm64
        shell: bash

      - name: Docker Publish Summary
        run: |
          if [ -z "$RELEASE_VERSION" ]; then
            export RELEASE_VERSION=$(node -p "require('./package.json').version")
          fi
          if [[ "${{ steps.check_image.outputs.image_exists }}" == "true" ]]; then
            echo "Image for version $RELEASE_VERSION already exists in the registry. No new image was built."
          fi
        shell: bash

  publish-hassio-addons:
    name: Update Submodule in hassio-addons
    runs-on: ubuntu-latest
    needs: [release]
    if: needs.release.outputs.new_release_published == 'true' && needs.release.outputs.new_release_version != ''
    steps:
      - name: Checkout hassio-addons repository
        uses: actions/checkout@v4
        with:
          repository: saya6k/hassio-addons # IMPORTANT: Confirm this is the correct parent repository
          token: ${{ secrets.HASSIO_ADDONS_TOKEN }} # PAT with write access to the parent repository
          path: hassio-addons # Checkout to a specific directory
          ref: main # IMPORTANT: Confirm this is the default branch of hassio-addons

      - name: Setup Git User
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
        working-directory: ./hassio-addons

      - name: Update mcp-grocy-api submodule
        env:
          RELEASE_TAG: ${{ needs.release.outputs.new_release_version }}
          SUBMODULE_PATH: mcp-grocy-api 
          CURRENT_REPO_URL: https://github.com/${{ github.repository }}.git
        run: |
          set -e # Exit immediately if a command exits with a non-zero status.
          echo "Attempting to update submodule '$SUBMODULE_PATH' to tag: $RELEASE_TAG"

          if [ -z "$RELEASE_TAG" ]; then
            echo "Error: RELEASE_TAG is empty. Cannot update submodule."
            exit 1
          fi

          if [ -f ".gitmodules" ] && grep -q "path = $SUBMODULE_PATH" .gitmodules; then
            echo "Submodule '$SUBMODULE_PATH' is configured. Initializing and updating..."
            git submodule update --init --force $SUBMODULE_PATH
          else
            echo "Submodule '$SUBMODULE_PATH' not configured or path does not exist. Adding it."
            rm -rf $SUBMODULE_PATH
            git submodule add --force --name $SUBMODULE_PATH $CURRENT_REPO_URL $SUBMODULE_PATH
          fi
          
          cd $SUBMODULE_PATH
          echo "Inside submodule directory: $(pwd)"

          echo "Fetching tags from origin..."
          git fetch origin --tags --force
          
          echo "--- Git Submodule Debug Info ---"
          echo "Current git status:"
          git status -sb # Short branch status
          echo "Local branches:"
          git branch
          echo "Last 5 tags (local):"
          git tag -l --sort=-creatordate | head -n 5
          echo "--------------------------------"

          echo "Resolving tag '$RELEASE_TAG' to a commit..."
          # Try to resolve the tag to a commit SHA. Handles both annotated and lightweight tags.
          # Also try with a 'v' prefix for the tag.
          TAG_COMMIT=$(git rev-parse --verify "$RELEASE_TAG^{commit}" 2>/dev/null || \
                       git rev-parse --verify "tags/$RELEASE_TAG^{commit}" 2>/dev/null || \
                       git rev-parse --verify "$RELEASE_TAG" 2>/dev/null || \
                       git rev-parse --verify "v$RELEASE_TAG^{commit}" 2>/dev/null || \
                       git rev-parse --verify "tags/v$RELEASE_TAG^{commit}" 2>/dev/null || \
                       git rev-parse --verify "v$RELEASE_TAG" 2>/dev/null)


          if [ -z "$TAG_COMMIT" ]; then
            echo "Error: Could not resolve tag '$RELEASE_TAG' to a commit in $SUBMODULE_PATH."
            echo "Listing all available local tags in $SUBMODULE_PATH (git tag -l):"
            git tag -l | cat # Use cat to ensure it's not truncated by log limits
            echo "Listing remote tags from 'git ls-remote --tags origin':"
            git ls-remote --tags origin | cat
            exit 1
          fi
          echo "Resolved tag '$RELEASE_TAG' to commit SHA: $TAG_COMMIT"

          echo "Attempting to checkout commit '$TAG_COMMIT' (derived from tag '$RELEASE_TAG')..."
          # Use -c advice.detachedHead=false to suppress the detached HEAD advice message.
          if git -c advice.detachedHead=false checkout "$TAG_COMMIT" --force; then
            CURRENT_HEAD_COMMIT=$(git rev-parse HEAD)
            if [ "$CURRENT_HEAD_COMMIT" == "$TAG_COMMIT" ]; then
              echo "Successfully checked out commit '$TAG_COMMIT' (from tag '$RELEASE_TAG')."
            else
              # This should not happen if 'git checkout $TAG_COMMIT' (a SHA) succeeds.
              echo "Error: After checkout, HEAD is at '$CURRENT_HEAD_COMMIT', but expected '$TAG_COMMIT'."
              exit 1
            fi
          else
            CHECKOUT_EC=$?
            echo "Error: 'git checkout \"$TAG_COMMIT\" --force' failed with exit code $CHECKOUT_EC."
            echo "This can happen if the commit object $TAG_COMMIT is not available locally, despite the tag being resolved."
            echo "Verifying commit object existence with 'git cat-file -t $TAG_COMMIT':"
            git cat-file -t "$TAG_COMMIT" || echo "cat-file check also failed for $TAG_COMMIT (exit code $?). This means the commit object is likely missing or corrupt."
            exit $CHECKOUT_EC
          fi
          
          cd .. 
          echo "Back in hassio-addons root: $(pwd)"

          git add $SUBMODULE_PATH
          if [ -f ".gitmodules" ]; then
            git add .gitmodules
          fi

          if git diff --staged --quiet; then
            echo "No changes to commit. Submodule '$SUBMODULE_PATH' might already be at tag '$RELEASE_TAG'."
          else
            echo "Changes detected. Committing and pushing to hassio-addons..."
            # Use printf for safer multi-line string construction for the commit message, all on one line for the shell
            COMMIT_MESSAGE=$(printf 'Update %s to %s\n\nTriggered by release of %s@%s\nCommit in %s: %s' "$SUBMODULE_PATH" "$RELEASE_TAG" "${{ github.repository }}" "$RELEASE_TAG" "${{ github.repository }}" "${{ github.sha }}")
            
            git commit -m "$COMMIT_MESSAGE"
            git push
            echo "Successfully pushed submodule update to hassio-addons."
          fi
        working-directory: ./hassio-addons # Ensure all commands run in the checked-out parent repo