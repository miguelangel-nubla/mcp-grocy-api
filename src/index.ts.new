#!/usr/bin/env node
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  CallToolRequestSchema,
  ErrorCode,
  ListToolsRequestSchema,
  ListResourcesRequestSchema,
  ReadResourceRequestSchema,
  McpError,
} from '@modelcontextprotocol/sdk/types.js';
import axios, { AxiosInstance, AxiosRequestConfig, Method } from 'axios';
import { VERSION, SERVER_NAME } from './version.js';

// Validate required environment variables
if (!process.env.GROCY_URL) {
  throw new Error('GROCY_URL environment variable is required');
}

if (!process.env.GROCY_API_KEY) {
  throw new Error('GROCY_API_KEY environment variable is required');
}

// Default response size limit: 10KB (10000 bytes)
const RESPONSE_SIZE_LIMIT = process.env.GROCY_RESPONSE_SIZE_LIMIT 
  ? parseInt(process.env.GROCY_RESPONSE_SIZE_LIMIT, 10)
  : 10000;

if (isNaN(RESPONSE_SIZE_LIMIT) || RESPONSE_SIZE_LIMIT <= 0) {
  throw new Error('GROCY_RESPONSE_SIZE_LIMIT must be a positive number');
}

const GROCY_PORT = process.env.GROCY_PORT || '443';
const GROCY_IGNORE_SSL = process.env.GROCY_IGNORE_SSL === 'True';

interface GrocyRequestArgs {
  endpoint: string;
  method?: 'GET' | 'POST' | 'PUT' | 'DELETE';
  body?: any;
  params?: Record<string, string>;
}

interface ValidationResult {
  isError: boolean;
  messages: string[];
  truncated?: {
    originalSize: number;
    returnedSize: number;
    truncationPoint: number;
    sizeLimit: number;
  };
}

interface ResponseObject {
  request: {
    url: string;
    method: string;
    headers: Record<string, string | undefined>;
    body: any;
  };
  response: {
    statusCode: number;
    statusText: string;
    timing: string;
    headers: Record<string, any>;
    body: any;
  };
  validation: ValidationResult;
}

const normalizeBaseUrl = (url: string): string => url.replace(/\/+$/, '');

const isValidGrocyRequestArgs = (args: any): args is GrocyRequestArgs => {
  if (typeof args !== 'object' || args === null) return false;
  if (typeof args.endpoint !== 'string') return false;
  
  if (args.method !== undefined && !['GET', 'POST', 'PUT', 'DELETE'].includes(args.method)) {
    return false;
  }
  
  if (args.params !== undefined && (typeof args.params !== 'object' || args.params === null)) {
    return false;
  }
  
  // Check if endpoint contains a full URL
  const urlPattern = /^(https?:\/\/|www\.)/i;
  if (urlPattern.test(args.endpoint)) {
    throw new McpError(
      ErrorCode.InvalidParams,
      `Invalid endpoint format. Do not include full URLs. Instead of "${args.endpoint}", use just the path (e.g. "/api/stock"). ` +
      `Your path will be resolved to: ${process.env.GROCY_URL}${args.endpoint.replace(/^\/+|\/+$/g, '')}. ` +
      `To test a different base URL, update the GROCY_URL environment variable.`
    );
  }
  
  return true;
};

class GrocyAPI {
  private server!: Server;
  private axiosInstance!: AxiosInstance;

  constructor() {
    this.setupServer();
  }

  private async setupServer() {
    this.server = new Server(
      {
        name: SERVER_NAME,
        version: VERSION,
      },
      {
        capabilities: {
          tools: {},
          resources: {},
        },
      }
    );

    const https = await import('https');
    this.axiosInstance = axios.create({
      baseURL: normalizeBaseUrl(process.env.GROCY_URL!),
      validateStatus: () => true, // Allow any status code
      httpsAgent: GROCY_IGNORE_SSL ? new https.Agent({ // Disable SSL verification when requested
        rejectUnauthorized: false
      }) : undefined
    });

    this.setupToolHandlers();
    this.setupResourceHandlers();
    
    this.server.onerror = (error) => console.error('[MCP Error]', error);
    process.on('SIGINT', async () => {
      await this.server.close();
      process.exit(0);
    });
  }

  private setupResourceHandlers() {
    this.server.setRequestHandler(ListResourcesRequestSchema, async () => ({
      resources: [
        {
          uri: `${SERVER_NAME}://examples`,
          name: 'Grocy API Usage Examples',
          description: 'Detailed examples of using the Grocy API',
          mimeType: 'text/markdown'
        },
        {
          uri: `${SERVER_NAME}://response-format`,
          name: 'Response Format Documentation',
          description: 'Documentation of the response format and structure',
          mimeType: 'text/markdown'
        },
        {
          uri: `${SERVER_NAME}://config`,
          name: 'Configuration Documentation',
          description: 'Documentation of all configuration options and how to use them',
          mimeType: 'text/markdown'
        }
      ]
    }));

    this.server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
      const uriPattern = new RegExp(`^${SERVER_NAME}://(.+)$`);
      const match = request.params.uri.match(uriPattern);
      
      if (!match) {
        throw new McpError(
          ErrorCode.InvalidRequest,
          `Invalid resource URI format: ${request.params.uri}`
        );
      }

      const resource = match[1];
      const fs = await import('fs');
      const path = await import('path');

      try {
        const url = await import('url');
        const __filename = url.fileURLToPath(import.meta.url);
        const __dirname = path.dirname(__filename);
        
        // In the built app, resources are in build/resources
        // In development, they're in src/resources
        const resourcePath = path.join(__dirname, 'resources', `${resource}.md`);
        const content = await fs.promises.readFile(resourcePath, 'utf8');

        return {
          contents: [{
            uri: request.params.uri,
            mimeType: 'text/markdown',
            text: content
          }]
        };
      } catch (error) {
        throw new McpError(
          ErrorCode.InvalidRequest,
          `Resource not found: ${resource}`
        );
      }
    });
  }

  private setupToolHandlers() {
    this.server.setRequestHandler(ListToolsRequestSchema, async () => ({
      tools: [
        {
          name: 'get_stock',
          description: `Get current stock information from your Grocy instance. This returns all stock items with details.`,
          inputSchema: {
            type: 'object',
            properties: {
              includeDetails: {
                type: 'boolean',
                description: 'Whether to include additional details about each stock item'
              }
            }
          }
        },
        {
          name: 'get_products',
          description: `Get product information from your Grocy instance.`,
          inputSchema: {
            type: 'object',
            properties: {
              query: {
                type: 'string',
                description: 'Optional search query to filter products by name'
              }
            }
          }
        },
        {
          name: 'get_product_by_id',
          description: `Get detailed information about a specific product by its ID.`,
          inputSchema: {
            type: 'object',
            properties: {
              productId: {
                type: 'number',
                description: 'The ID of the product to retrieve'
              }
            },
            required: ['productId']
          }
        },
        {
          name: 'get_locations',
          description: `Get all storage locations from your Grocy instance.`
        },
        {
          name: 'get_shopping_list',
          description: `Get your current shopping list items.`
        },
        {
          name: 'call_grocy_api',
          description: `Make a custom API call to your Grocy instance. For advanced users who need to access specific endpoints.`,
          inputSchema: {
            type: 'object',
            properties: {
              endpoint: {
                type: 'string',
                description: `API endpoint path (e.g. "/api/stock"). Do not include full URLs - only the path. Will be appended to your configured Grocy URL.`
              },
              method: {
                type: 'string',
                enum: ['GET', 'POST', 'PUT', 'DELETE'],
                description: 'HTTP method to use for the request.',
                default: 'GET'
              },
              body: {
                type: 'object',
                description: 'Optional request body for POST/PUT requests'
              },
              params: {
                type: 'object',
                description: 'Optional query parameters',
                additionalProperties: {
                  type: 'string'
                }
              }
            },
            required: ['endpoint']
          }
        }
      ]
    }));

    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      try {
        switch (request.params.name) {
          case 'get_stock':
            return await this.handleGetStock(request.params.arguments);
          case 'get_products':
            return await this.handleGetProducts(request.params.arguments);
          case 'get_product_by_id':
            return await this.handleGetProductById(request.params.arguments);
          case 'get_locations':
            return await this.handleGetLocations();
          case 'get_shopping_list':
            return await this.handleGetShoppingList();
          case 'call_grocy_api':
            return await this.handleCallGrocyAPI(request.params.arguments);
          default:
            throw new McpError(
              ErrorCode.MethodNotFound,
              `Unknown tool: ${request.params.name}`
            );
        }
      } catch (error) {
        if (axios.isAxiosError(error)) {
          return {
            content: [
              {
                type: 'text',
                text: JSON.stringify({
                  error: {
                    message: error.message,
                    code: error.code || error.response?.status,
                    response: error.response?.data
                  }
                }, null, 2),
              },
            ],
            isError: true,
          };
        }
        if (error instanceof McpError) {
          throw error;
        }
        throw new McpError(
          ErrorCode.InternalError,
          `An unexpected error occurred: ${error}`
        );
      }
    });
  }

  private async makeGrocyRequest(endpoint: string, method: Method = 'GET', body?: any, params?: Record<string, string>) {
    // Ensure endpoint starts with / and remove any trailing slashes
    const normalizedEndpoint = `/${endpoint.replace(/^\/+|\/+$/g, '')}`;
    
    // Initialize request config
    const config: AxiosRequestConfig = {
      method,
      url: normalizedEndpoint,
      headers: {
        'GROCY-API-KEY': process.env.GROCY_API_KEY!,
        'Accept': 'application/json',
        'Content-Type': 'application/json'
      },
      params
    };

    // Add request body for POST/PUT
    if (['POST', 'PUT'].includes(method) && body) {
      config.data = body;
    }

    const startTime = Date.now();
    const response = await this.axiosInstance.request(config);
    const endTime = Date.now();
    const fullUrl = `${normalizeBaseUrl(process.env.GROCY_URL!)}${normalizedEndpoint}`;

    // Prepare response object
    const responseObj: ResponseObject = {
      request: {
        url: fullUrl,
        method: config.method || 'GET',
        headers: config.headers as Record<string, string | undefined>,
        body: config.data
      },
      response: {
        statusCode: response.status,
        statusText: response.statusText,
        timing: `${endTime - startTime}ms`,
        headers: response.headers,
        body: response.data
      },
      validation: {
        isError: response.status >= 400,
        messages: response.status >= 400 ? 
          [`Request failed with status ${response.status}`] : 
          ['Request completed successfully']
      }
    };

    // Check response body size independently
    const bodyStr = typeof response.data === 'string' 
      ? response.data 
      : JSON.stringify(response.data);
    const bodySize = Buffer.from(bodyStr).length;

    if (bodySize > RESPONSE_SIZE_LIMIT) {
      // Simply truncate to the size limit
      responseObj.response.body = typeof response.data === 'string'
        ? bodyStr.slice(0, RESPONSE_SIZE_LIMIT)
        : JSON.parse(bodyStr.slice(0, RESPONSE_SIZE_LIMIT));
        
      responseObj.validation.messages.push(
        `Response truncated: ${RESPONSE_SIZE_LIMIT} of ${bodySize} bytes returned due to size limit (${RESPONSE_SIZE_LIMIT} bytes)`
      );
      responseObj.validation.truncated = {
        originalSize: bodySize,
        returnedSize: RESPONSE_SIZE_LIMIT,
        truncationPoint: RESPONSE_SIZE_LIMIT,
        sizeLimit: RESPONSE_SIZE_LIMIT
      };
    }

    return responseObj;
  }

  private async handleGetStock(args: any = {}) {
    const includeDetails = args.includeDetails === true;
    const response = await this.makeGrocyRequest('/api/stock', 'GET');
    
    if (response.validation.isError) {
      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify(response, null, 2)
          }
        ],
        isError: true
      };
    }

    // If not including details, simplify the response
    if (!includeDetails && Array.isArray(response.response.body)) {
      response.response.body = response.response.body.map((item: any) => ({
        product_id: item.product_id,
        product_name: item.product?.name,
        amount: item.amount,
        best_before_date: item.best_before_date,
        location: item.product?.location_id,
        amount_opened: item.amount_opened,
        value: item.value
      }));
    }

    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify(response.response.body, null, 2)
        }
      ]
    };
  }

  private async handleGetProducts(args: any = {}) {
    const response = await this.makeGrocyRequest('/api/objects/products', 'GET');
    
    if (response.validation.isError) {
      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify(response, null, 2)
          }
        ],
        isError: true
      };
    }

    let products = response.response.body;
    
    // Filter products if query is provided
    if (args.query && typeof args.query === 'string' && Array.isArray(products)) {
      const query = args.query.toLowerCase();
      products = products.filter((product: any) => 
        product.name.toLowerCase().includes(query)
      );
    }

    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify(products, null, 2)
        }
      ]
    };
  }

  private async handleGetProductById(args: any) {
    if (typeof args.productId !== 'number') {
      throw new McpError(
        ErrorCode.InvalidParams,
        'productId must be a number'
      );
    }

    const response = await this.makeGrocyRequest(`/api/objects/products/${args.productId}`, 'GET');
    
    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify(response.response.body, null, 2)
        }
      ],
      isError: response.validation.isError
    };
  }

  private async handleGetLocations() {
    const response = await this.makeGrocyRequest('/api/objects/locations', 'GET');
    
    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify(response.response.body, null, 2)
        }
      ],
      isError: response.validation.isError
    };
  }

  private async handleGetShoppingList() {
    const response = await this.makeGrocyRequest('/api/objects/shopping_list', 'GET');
    
    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify(response.response.body, null, 2)
        }
      ],
      isError: response.validation.isError
    };
  }

  private async handleCallGrocyAPI(args: any) {
    if (!isValidGrocyRequestArgs(args)) {
      throw new McpError(
        ErrorCode.InvalidParams,
        'Invalid Grocy API request arguments'
      );
    }

    const method = args.method || 'GET';
    const response = await this.makeGrocyRequest(args.endpoint, method as Method, args.body, args.params);
    
    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify(response, null, 2)
        }
      ],
      isError: response.validation.isError
    };
  }

  async run() {
    await this.setupServer();
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.error('Grocy API MCP server running on stdio');
  }
}

const server = new GrocyAPI();
server.run().catch(console.error);
